import csv
from matplotlib import pyplot as plt
import numpy as np

query_results = {}
map_idx_to_column = {}

'''
Assumes the csv is generated by Hive. 
Can have any number of columns but must include 'ttls' and 'ts'
Assumes table name is prepended to column name
'''
def readHiveResultFile(filename):
    with open(filename) as csvfile:
        readCSV = csv.reader(csvfile, delimiter=',')
        for idx, row in enumerate(readCSV):

            # Get the column names and strip off the table name
            if idx == 0:
                for i, item in enumerate(row):
                    strippedName = item.split('.')[1]
                    query_results[strippedName] = []
                    map_idx_to_column[i] = strippedName
                continue

            # Store items in appropriate columns
            for i, item in enumerate(row):
                colName = map_idx_to_column[i]
                if colName == 'ts':
                    if idx == 1:
                        start_ts = float(item)
                    query_results[colName].append(float(item) - start_ts)
                elif colName == 'ttls':
                    query_results[colName].append(float(item))
                else:
                    query_results[colName].append(item)

'''
Assumes the csv looks like this:

response_time, ttl
6, 255
6, 201

csv files like this are generated by timing_attack.sh
'''
def readDigResults(filename):
    with open(filename) as csvfile:
        readCSV = csv.reader(csvfile, delimiter=',')
        map_column_to_idx = {}
        for idx, row in enumerate(readCSV):

            # Get the column names and strip off the table name
            if idx == 0:
                print(row)
                for i, name in enumerate(row):
                    map_idx_to_column[i] = name
                    map_column_to_idx[name] = i
                    query_results[name] = []
                continue

            # Horrible hack for separating servers
            resp_col = map_column_to_idx['response_time']
            if int(row[resp_col]) > 20:
                continue

            # Store items in appropriate columns
            for i, item in enumerate(row):
                colName = map_idx_to_column[i]
                query_results[colName].append(int(item))


def plotTsVsTTLs(start, end, filename):
    plt.plot(query_results['ts'][start:end], query_results['ttls'][start:end], linestyle="",marker="o", markersize=2.0)
    plt.grid(axis='x', linewidth=0.5, linestyle = 'dashed')
    #plt.xticks(np.arange(start, end, 300))
    plt.xticks(np.arange(int(query_results['ts'][start]), int(query_results['ts'][end]), 300))
    plt.xlabel('Timestamp (seconds since first timestamp)')
    plt.ylabel('TTL (seconds)')
    title = 'TTL lines for ' + str(int(query_results['ts'][start])) + ' seconds to ' + str(int(query_results['ts'][end])) + ' seconds'
    plt.title(title)
    figname = filename.split('.')[0] + '_' + str(start) + '_' + str(end) + '.png'
    plt.savefig(figname)
    plt.show()

def plotRespTimeVsTTLs():
    plt.plot(query_results['response_time'], query_results[' ttl'], linestyle="",marker="o", markersize=2.0)
    plt.xlabel('Response time (ms)')
    plt.ylabel('TTL (seconds)')
    title = 'TTLs vs response times: query for facebook.com to 8.8.8.8,\n recursion desired'
    plt.title(title)
    figname = 'resp_time_vs_ttl_facebookcom.png'
    plt.savefig(figname)
    plt.show()

def plotWallTimeVsTTLs():
    plt.plot(query_results[' time_elapsed'], query_results[' ttl'], linestyle="",marker="o", markersize=2.0)
    plt.xlabel('Time elapsed (seconds)')
    plt.ylabel('TTL (seconds)')
    title = 'TTLs vs time elapsed: query for facebook.com to 8.8.8.8,\n recursion desired'
    plt.title(title)
    #figname = 'wall_time_vs_ttl_facebookcom.png'
    #plt.savefig(figname)
    plt.show()

def makeHiveGraph(filename):
    readHiveResultFile()
    plotTsVsTTLs()

def makeDigGraph(filename):
    readDigResults(filename)
    #plotRespTimeVsTTLs()
    print(query_results['response_time'])
    plotWallTimeVsTTLs()

filename = "timing_attack_3.csv"
makeDigGraph(filename)